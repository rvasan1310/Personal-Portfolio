#!/usr/bin/env python3
"""
Enterprise Vulnerability Assessment Framework
Author: Ram Vasani
Towson University - Computer Science Senior

A comprehensive automated penetration testing suite that scans enterprise networks 
for OWASP Top 10 vulnerabilities with custom exploit modules and detailed reporting.
"""

import nmap
import requests
import socket
import threading
import json
import time
import subprocess
import argparse
from datetime import datetime
from urllib.parse import urljoin, urlparse
import ssl
import warnings
from concurrent.futures import ThreadPoolExecutor, as_completed

warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class VulnerabilityScanner:
    def __init__(self, target, output_file='vulnerability_report.json'):
        self.target = target
        self.output_file = output_file
        self.results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'vulnerabilities': [],
            'open_ports': [],
            'ssl_info': {},
            'risk_score': 0
        }
        self.nm = nmap.PortScanner()
        
    def port_scan(self):
        """Perform comprehensive port scan using nmap"""
        print(f"[+] Starting port scan on {self.target}")
        try:
            # Scan common ports and service detection
            self.nm.scan(self.target, '21-443,993,995,8080,8443', '-sV -sC --script vuln')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    ports = self.nm[host][proto].keys()
                    for port in ports:
                        port_info = {
                            'port': port,
                            'state': self.nm[host][proto][port]['state'],
                            'service': self.nm[host][proto][port].get('name', 'unknown'),
                            'version': self.nm[host][proto][port].get('version', ''),
                            'product': self.nm[host][proto][port].get('product', '')
                        }
                        self.results['open_ports'].append(port_info)
                        
                        # Check for known vulnerable services
                        self._check_service_vulnerabilities(port, port_info)
                        
            print(f"[+] Found {len(self.results['open_ports'])} open ports")
            
        except Exception as e:
            print(f"[-] Port scan failed: {str(e)}")
    
    def _check_service_vulnerabilities(self, port, port_info):
        """Check for known vulnerabilities in detected services"""
        service = port_info['service'].lower()
        version = port_info.get('version', '').lower()
        
        # Check for common vulnerable services
        vulnerable_services = {
            'ssh': self._check_ssh_vulnerabilities,
            'ftp': self._check_ftp_vulnerabilities,
            'http': self._check_http_vulnerabilities,
            'https': self._check_http_vulnerabilities,
            'mysql': self._check_mysql_vulnerabilities,
            'telnet': self._check_telnet_vulnerabilities
        }
        
        if service in vulnerable_services:
            vulnerable_services[service](port, version)
    
    def _check_ssh_vulnerabilities(self, port, version):
        """Check SSH for common vulnerabilities"""
        vulnerabilities = []
        
        # Check for weak SSH configuration
        if 'openssh' in version:
            if any(v in version for v in ['5.', '6.', '7.0', '7.1', '7.2']):
                vulnerabilities.append({
                    'type': 'Outdated SSH Version',
                    'severity': 'Medium',
                    'description': f'SSH version {version} may contain known vulnerabilities',
                    'port': port,
                    'cve': 'CVE-2016-0777, CVE-2016-0778'
                })
        
        # Check for SSH brute force possibility
        vulnerabilities.append({
            'type': 'SSH Brute Force Risk',
            'severity': 'Low',
            'description': 'SSH service exposed - potential brute force target',
            'port': port,
            'recommendation': 'Implement fail2ban, key-based auth, non-standard port'
        })
        
        self.results['vulnerabilities'].extend(vulnerabilities)
    
    def _check_ftp_vulnerabilities(self, port, version):
        """Check FTP for vulnerabilities"""
        vulnerabilities = []
        
        # Check for anonymous FTP
        try:
            import ftplib
            ftp = ftplib.FTP(timeout=5)
            ftp.connect(self.target, port)
            try:
                ftp.login('anonymous', 'anonymous')
                vulnerabilities.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'description': 'FTP allows anonymous login',
                    'port': port,
                    'recommendation': 'Disable anonymous access'
                })
            except:
                pass
            ftp.quit()
        except:
            pass
        
        self.results['vulnerabilities'].extend(vulnerabilities)
    
    def _check_http_vulnerabilities(self, port, version):
        """Check HTTP/HTTPS services for web vulnerabilities"""
        scheme = 'https' if port in [443, 8443] else 'http'
        base_url = f"{scheme}://{self.target}:{port}"
        
        print(f"[+] Scanning web application on {base_url}")
        
        # Check for common web vulnerabilities
        self._check_sql_injection(base_url)
        self._check_xss(base_url)
        self._check_directory_traversal(base_url)
        self._check_security_headers(base_url)
        self._check_common_files(base_url)
        
        if scheme == 'https':
            self._check_ssl_vulnerabilities(port)
    
    def _check_sql_injection(self, base_url):
        """Test for SQL injection vulnerabilities"""
        payloads = ["'", "' OR '1'='1", "'; DROP TABLE users; --", "1' UNION SELECT 1,2,3--"]
        
        # Common parameter names to test
        params_to_test = ['id', 'user', 'username', 'email', 'search', 'q']
        
        for payload in payloads:
            for param in params_to_test:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    response = requests.get(test_url, timeout=5, verify=False)
                    
                    # Look for SQL error messages
                    sql_errors = [
                        'sql syntax', 'mysql_fetch', 'ora-', 'microsoft jet database',
                        'sqlite_master', 'postgresql', 'pg_class'
                    ]
                    
                    if any(error in response.text.lower() for error in sql_errors):
                        self.results['vulnerabilities'].append({
                            'type': 'SQL Injection',
                            'severity': 'Critical',
                            'description': f'Potential SQL injection found with payload: {payload}',
                            'url': test_url,
                            'recommendation': 'Use parameterized queries and input validation'
                        })
                        break
                        
                except requests.exceptions.RequestException:
                    continue
    
    def _check_xss(self, base_url):
        """Test for Cross-Site Scripting vulnerabilities"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "javascript:alert('XSS')",
            '<img src=x onerror=alert("XSS")>'
        ]
        
        params_to_test = ['q', 'search', 'input', 'data', 'comment']
        
        for payload in xss_payloads:
            for param in params_to_test:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    response = requests.get(test_url, timeout=5, verify=False)
                    
                    if payload in response.text and 'text/html' in response.headers.get('content-type', ''):
                        self.results['vulnerabilities'].append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'High',
                            'description': f'Reflected XSS found with payload: {payload}',
                            'url': test_url,
                            'recommendation': 'Implement output encoding and CSP headers'
                        })
                        break
                        
                except requests.exceptions.RequestException:
                    continue
    
    def _check_directory_traversal(self, base_url):
        """Test for directory traversal vulnerabilities"""
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
        ]
        
        for payload in traversal_payloads:
            try:
                test_url = f"{base_url}/file?path={payload}"
                response = requests.get(test_url, timeout=5, verify=False)
                
                # Look for signs of successful directory traversal
                if any(indicator in response.text.lower() for indicator in ['root:', 'bin:', 'daemon:', '[fonts]']):
                    self.results['vulnerabilities'].append({
                        'type': 'Directory Traversal',
                        'severity': 'High',
                        'description': f'Directory traversal found with payload: {payload}',
                        'url': test_url,
                        'recommendation': 'Implement proper input validation and file path restrictions'
                    })
                    break
                    
            except requests.exceptions.RequestException:
                continue
    
    def _check_security_headers(self, base_url):
        """Check for missing security headers"""
        try:
            response = requests.get(base_url, timeout=5, verify=False)
            headers = response.headers
            
            required_headers = {
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'X-Frame-Options': 'Missing X-Frame-Options header - clickjacking risk',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing Content Security Policy'
            }
            
            for header, description in required_headers.items():
                if header not in headers:
                    self.results['vulnerabilities'].append({
                        'type': 'Missing Security Header',
                        'severity': 'Medium',
                        'description': description,
                        'url': base_url,
                        'recommendation': f'Implement {header} header'
                    })
                    
        except requests.exceptions.RequestException:
            pass
    
    def _check_common_files(self, base_url):
        """Check for common sensitive files"""
        common_files = [
            '/robots.txt',
            '/.git/',
            '/.env',
            '/config.php',
            '/admin/',
            '/phpmyadmin/',
            '/wp-admin/',
            '/backup/',
            '/test.php',
            '/phpinfo.php'
        ]
        
        for file_path in common_files:
            try:
                test_url = urljoin(base_url, file_path)
                response = requests.get(test_url, timeout=3, verify=False)
                
                if response.status_code == 200:
                    severity = 'High' if file_path in ['/.env', '/config.php', '/.git/'] else 'Medium'
                    self.results['vulnerabilities'].append({
                        'type': 'Information Disclosure',
                        'severity': severity,
                        'description': f'Sensitive file accessible: {file_path}',
                        'url': test_url,
                        'recommendation': 'Restrict access to sensitive files'
                    })
                    
            except requests.exceptions.RequestException:
                continue
    
    def _check_ssl_vulnerabilities(self, port):
        """Check SSL/TLS configuration"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((self.target, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    self.results['ssl_info'] = {
                        'cipher_suite': cipher[0] if cipher else 'Unknown',
                        'protocol_version': cipher[1] if cipher else 'Unknown',
                        'key_exchange': cipher[2] if cipher else 'Unknown'
                    }
                    
                    # Check for weak ciphers
                    if cipher and 'RC4' in cipher[0]:
                        self.results['vulnerabilities'].append({
                            'type': 'Weak SSL Cipher',
                            'severity': 'Medium',
                            'description': 'Weak RC4 cipher suite detected',
                            'port': port,
                            'recommendation': 'Disable RC4 and use strong cipher suites'
                        })
                    
                    # Check certificate expiration
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.now()).days
                        
                        if days_until_expiry < 30:
                            severity = 'High' if days_until_expiry < 0 else 'Medium'
                            self.results['vulnerabilities'].append({
                                'type': 'SSL Certificate Issue',
                                'severity': severity,
                                'description': f'SSL certificate expires in {days_until_expiry} days',
                                'port': port,
                                'recommendation': 'Renew SSL certificate'
                            })
                            
        except Exception:
            pass
    
    def _check_mysql_vulnerabilities(self, port, version):
        """Check MySQL for common vulnerabilities"""
        vulnerabilities = []
        
        # Check for default credentials
        try:
            import pymysql
            connection = pymysql.connect(
                host=self.target,
                port=port,
                user='root',
                password='',
                connect_timeout=5
            )
            
            vulnerabilities.append({
                'type': 'Default MySQL Credentials',
                'severity': 'Critical',
                'description': 'MySQL accessible with default root credentials',
                'port': port,
                'recommendation': 'Change default MySQL root password'
            })
            
            connection.close()
            
        except:
            pass
        
        self.results['vulnerabilities'].extend(vulnerabilities)
    
    def _check_telnet_vulnerabilities(self, port, version):
        """Check Telnet vulnerabilities"""
        self.results['vulnerabilities'].append({
            'type': 'Insecure Protocol',
            'severity': 'High',
            'description': 'Telnet service detected - unencrypted communication',
            'port': port,
            'recommendation': 'Replace Telnet with SSH'
        })
    
    def calculate_risk_score(self):
        """Calculate overall risk score based on vulnerabilities"""
        severity_scores = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }
        
        total_score = 0
        for vuln in self.results['vulnerabilities']:
            total_score += severity_scores.get(vuln['severity'], 0)
        
        self.results['risk_score'] = min(total_score, 100)  # Cap at 100
    
    def generate_report(self):
        """Generate detailed vulnerability report"""
        self.calculate_risk_score()
        
        # Save JSON report
        with open(self.output_file, 'w') as f:
            json.dump(self.results, f, indent=4, default=str)
        
        # Generate human-readable report
        html_report = self._generate_html_report()
        html_file = self.output_file.replace('.json', '.html')
        with open(html_file, 'w') as f:
            f.write(html_report)
        
        print(f"\n[+] Scan completed!")
        print(f"[+] Found {len(self.results['vulnerabilities'])} vulnerabilities")
        print(f"[+] Risk Score: {self.results['risk_score']}/100")
        print(f"[+] Reports saved: {self.output_file}, {html_file}")
    
    def _generate_html_report(self):
        """Generate HTML vulnerability report"""
        risk_color = 'red' if self.results['risk_score'] > 70 else 'orange' if self.results['risk_score'] > 40 else 'green'
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Assessment Report - {self.target}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
                .risk-score {{ font-size: 24px; color: {risk_color}; font-weight: bold; }}
                .vuln-critical {{ background: #e74c3c; color: white; }}
                .vuln-high {{ background: #e67e22; color: white; }}
                .vuln-medium {{ background: #f39c12; color: white; }}
                .vuln-low {{ background: #27ae60; color: white; }}
                .vulnerability {{ margin: 10px 0; padding: 15px; border-radius: 5px; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Assessment Report</h1>
                <p><strong>Target:</strong> {self.target}</p>
                <p><strong>Scan Date:</strong> {self.results['scan_time']}</p>
                <p><strong>Risk Score:</strong> <span class="risk-score">{self.results['risk_score']}/100</span></p>
            </div>
            
            <h2>Executive Summary</h2>
            <p>This report contains the results of an automated vulnerability assessment performed on {self.target}.</p>
            <ul>
                <li><strong>Total Vulnerabilities:</strong> {len(self.results['vulnerabilities'])}</li>
                <li><strong>Open Ports:</strong> {len(self.results['open_ports'])}</li>
                <li><strong>Risk Level:</strong> {'High' if self.results['risk_score'] > 70 else 'Medium' if self.results['risk_score'] > 40 else 'Low'}</li>
            </ul>
            
            <h2>Open Ports</h2>
            <table>
                <tr><th>Port</th><th>State</th><th>Service</th><th>Version</th></tr>
        """
        
        for port in self.results['open_ports']:
            html += f"<tr><td>{port['port']}</td><td>{port['state']}</td><td>{port['service']}</td><td>{port.get('version', 'Unknown')}</td></tr>"
        
        html += """
            </table>
            
            <h2>Vulnerabilities</h2>
        """
        
        # Group vulnerabilities by severity
        severity_order = ['Critical', 'High', 'Medium', 'Low']
        for severity in severity_order:
            vulns = [v for v in self.results['vulnerabilities'] if v['severity'] == severity]
            if vulns:
                html += f"<h3>{severity} Severity ({len(vulns)})</h3>"
                for vuln in vulns:
                    css_class = f"vuln-{severity.lower()}"
                    html += f"""
                    <div class="vulnerability {css_class}">
                        <h4>{vuln['type']}</h4>
                        <p><strong>Description:</strong> {vuln['description']}</p>
                    """
                    if 'url' in vuln:
                        html += f"<p><strong>URL:</strong> {vuln['url']}</p>"
                    if 'port' in vuln:
                        html += f"<p><strong>Port:</strong> {vuln['port']}</p>"
                    if 'recommendation' in vuln:
                        html += f"<p><strong>Recommendation:</strong> {vuln['recommendation']}</p>"
                    html += "</div>"
        
        html += """
            <h2>Recommendations</h2>
            <ul>
                <li>Address Critical and High severity vulnerabilities immediately</li>
                <li>Implement security headers for web applications</li>
                <li>Regular security updates and patches</li>
                <li>Network segmentation and access controls</li>
                <li>Regular vulnerability assessments</li>
            </ul>
        </body>
        </html>
        """
        
        return html
    
    def run_full_scan(self):
        """Execute complete vulnerability assessment"""
        print(f"[+] Starting vulnerability assessment on {self.target}")
        print(f"[+] Scan initiated at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        try:
            self.port_scan()
            self.generate_report()
        except KeyboardInterrupt:
            print("\n[-] Scan interrupted by user")
        except Exception as e:
            print(f"[-] Scan failed: {str(e)}")

def main():
    parser = argparse.ArgumentParser(description='Enterprise Vulnerability Assessment Framework')
    parser.add_argument('target', help='Target IP address or hostname')
    parser.add_argument('-o', '--output', default='vulnerability_report.json', 
                       help='Output file for results')
    
    args = parser.parse_args()
    
    # Banner
    print("""
    ╔══════════════════════════════════════════════════════════╗
    ║          Enterprise Vulnerability Scanner v1.0           ║
    ║                   By Ram Vasani                          ║
    ║              Towson University - CS                      ║
    ╚══════════════════════════════════════════════════════════╝
    """)
    
    scanner = VulnerabilityScanner(args.target, args.output)
    scanner.run_full_scan()

if __name__ == "__main__":
    main()
